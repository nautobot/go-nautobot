/*
API Documentation

Source of truth and network automation platform

API version: 2.3.2 (2.3)
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package nautobot

import (
	"encoding/json"
	"fmt"
)

// RelationshipTypeChoices the model 'RelationshipTypeChoices'
type RelationshipTypeChoices string

// List of RelationshipTypeChoices
const (
	RELATIONSHIPTYPECHOICES_ONE_TO_ONE RelationshipTypeChoices = "one-to-one"
	RELATIONSHIPTYPECHOICES_SYMMETRIC_ONE_TO_ONE RelationshipTypeChoices = "symmetric-one-to-one"
	RELATIONSHIPTYPECHOICES_ONE_TO_MANY RelationshipTypeChoices = "one-to-many"
	RELATIONSHIPTYPECHOICES_MANY_TO_MANY RelationshipTypeChoices = "many-to-many"
	RELATIONSHIPTYPECHOICES_SYMMETRIC_MANY_TO_MANY RelationshipTypeChoices = "symmetric-many-to-many"
)

// All allowed values of RelationshipTypeChoices enum
var AllowedRelationshipTypeChoicesEnumValues = []RelationshipTypeChoices{
	"one-to-one",
	"symmetric-one-to-one",
	"one-to-many",
	"many-to-many",
	"symmetric-many-to-many",
}

func (v *RelationshipTypeChoices) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := RelationshipTypeChoices(value)
	for _, existing := range AllowedRelationshipTypeChoicesEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid RelationshipTypeChoices", value)
}

// NewRelationshipTypeChoicesFromValue returns a pointer to a valid RelationshipTypeChoices
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewRelationshipTypeChoicesFromValue(v string) (*RelationshipTypeChoices, error) {
	ev := RelationshipTypeChoices(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for RelationshipTypeChoices: valid values are %v", v, AllowedRelationshipTypeChoicesEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v RelationshipTypeChoices) IsValid() bool {
	for _, existing := range AllowedRelationshipTypeChoicesEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to RelationshipTypeChoices value
func (v RelationshipTypeChoices) Ptr() *RelationshipTypeChoices {
	return &v
}

type NullableRelationshipTypeChoices struct {
	value *RelationshipTypeChoices
	isSet bool
}

func (v NullableRelationshipTypeChoices) Get() *RelationshipTypeChoices {
	return v.value
}

func (v *NullableRelationshipTypeChoices) Set(val *RelationshipTypeChoices) {
	v.value = val
	v.isSet = true
}

func (v NullableRelationshipTypeChoices) IsSet() bool {
	return v.isSet
}

func (v *NullableRelationshipTypeChoices) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableRelationshipTypeChoices(val *RelationshipTypeChoices) *NullableRelationshipTypeChoices {
	return &NullableRelationshipTypeChoices{value: val, isSet: true}
}

func (v NullableRelationshipTypeChoices) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableRelationshipTypeChoices) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

